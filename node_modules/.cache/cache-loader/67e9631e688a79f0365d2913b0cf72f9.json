{"remainingRequest":"C:\\ws\\graph-drill\\.yarn\\__virtual__\\babel-loader-virtual-fd8dd261de\\0\\cache\\babel-loader-npm-8.2.2-b4e600c2c5-df5092ef98.zip\\node_modules\\babel-loader\\lib\\index.js??ruleSet[1].rules[0].use[1]!C:\\ws\\graph-drill\\.yarn\\__virtual__\\ts-loader-virtual-aa0d54d245\\0\\cache\\ts-loader-npm-9.2.1-40e1a5908e-1f2e61905d.zip\\node_modules\\ts-loader\\index.js??ruleSet[1].rules[0].use[2]!C:\\ws\\graph-drill\\src\\arquero\\table.ts","dependencies":[{"path":"C:\\ws\\graph-drill\\src\\arquero\\table.ts","mtime":1631029334675},{"path":"C:\\ws\\graph-drill\\.yarn\\__virtual__\\cache-loader-virtual-2fd14a2267\\0\\cache\\cache-loader-npm-4.1.0-82c3da90d8-0339778bdd.zip\\node_modules\\cache-loader\\dist\\cjs.js","mtime":456789000000},{"path":"C:\\ws\\graph-drill\\.yarn\\__virtual__\\babel-loader-virtual-fd8dd261de\\0\\cache\\babel-loader-npm-8.2.2-b4e600c2c5-df5092ef98.zip\\node_modules\\babel-loader\\lib\\index.js","mtime":456789000000},{"path":"C:\\ws\\graph-drill\\.yarn\\__virtual__\\ts-loader-virtual-aa0d54d245\\0\\cache\\ts-loader-npm-9.2.1-40e1a5908e-1f2e61905d.zip\\node_modules\\ts-loader\\index.js","mtime":456789000000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyohDQogKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC4NCiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdC4NCiAqLwppbXBvcnQgeyBST09UX0NPTU1VTklUWV9JRCB9IGZyb20gJy4uL2NvbnN0YW50cyc7CmltcG9ydCB7IGFsbCwgbm90LCBvcCB9IGZyb20gJ2FycXVlcm8nOwovKioNCiAqIEV4dHJhY3RzIHRoZSBvYmplY3RzIGZyb20gYSBzaW5nbGUtcm93IHRhYmxlLg0KICogVGhpcyBpcyBjb21tb25seSBuZWVkZWQgd2hlbiBkb2luZyByb2xsdXBzIHRoYXQgb3V0cHV0DQogKiBhIHNpbmdsZSByb3cgb2Ygc3RhdHMuDQogKiBAcGFyYW0gdGFibGUNCiAqLwovLyBUT0RPOiB0aGlzIGlzIHByZXR0eSBiYXNpYywgYnV0IHRoZSBpbnRlbnQgd291bGQgYmUgdG8gcHJvdmlkZSBvcHRpb25hbAovLyB0cmFuc2Zvcm1lcnMgcGVyIGNvbHVtbiBvciBhcyBhIHdob2xlCgpleHBvcnQgZnVuY3Rpb24gb25lKHRhYmxlKSB7CiAgcmV0dXJuIHRhYmxlLm9iamVjdHMoKVswXTsKfQovKioNCiAqIFJldHVybiBhIHNlbGVjdGlvbiBtYXBwaW5nIHRoYXQgcmVuYW1lcyBjb2x1bW5zIHdpdGggYSBwcmVmaXguDQogKiBAcGFyYW0gdGFibGUgdGFibGUgdG8gZW51bWVyYXRlIGFuZCByZW5hbWUgY29sdW1ucw0KICogQHBhcmFtIHByZWZpeCBwcmVmaXggdG8gYWRkIHRvIGNvbHVtbiBuYW1lcw0KICogQHBhcmFtIGV4Y2x1ZGUgZXhjbHVzaW9uIGxpc3QgaWYgeW91IHdhbnQgdG8gcmV0YWluIHNvbWUgb3JpZ2luYWwgY29sdW1ucw0KICovCgpleHBvcnQgZnVuY3Rpb24gcmVuYW1lKHRhYmxlLCBwcmVmaXgsIGV4Y2x1ZGUpIHsKICBjb25zdCBleCA9IG5ldyBTZXQoZXhjbHVkZSk7CiAgcmV0dXJuIHRhYmxlLmNvbHVtbk5hbWVzKCkucmVkdWNlKChvYmosIG5hbWUpID0+IHsKICAgIGlmIChleC5oYXMobmFtZSkgfHwgbmFtZS5zdGFydHNXaXRoKHByZWZpeCkpIHsKICAgICAgb2JqW25hbWVdID0gbmFtZTsKICAgIH0gZWxzZSB7CiAgICAgIG9ialtuYW1lXSA9IGAke3ByZWZpeH0ke25hbWV9YDsKICAgIH0KCiAgICByZXR1cm4gb2JqOwogIH0sIHt9KTsKfQpleHBvcnQgZnVuY3Rpb24gaGFzQ29sdW1uKHRhYmxlLCBjb2x1bW4pIHsKICByZXR1cm4gdGFibGUuY29sdW1uTmFtZXMoKS5zb21lKG5hbWUgPT4gbmFtZSA9PT0gY29sdW1uKTsKfQpleHBvcnQgZnVuY3Rpb24gY29sdW1uVHlwZXModGFibGUpIHsKICBpZiAodGFibGUubnVtUm93cygpID09PSAwKSB7CiAgICByZXR1cm4gW107CiAgfQoKICByZXR1cm4gdGFibGUuY29sdW1uTmFtZXMoKS5tYXAobmFtZSA9PiAoewogICAgbmFtZSwKICAgIHR5cGU6IHR5cGVvZiB0YWJsZS5nZXQobmFtZSwgMCkKICB9KSk7Cn0KZXhwb3J0IGZ1bmN0aW9uIHJlY29tcHV0ZUNvbW11bml0eVN0YXRzKHRhYmxlLCBmb3JjZSkgewogIGNvbnN0IHNlbGVjdGVkID0gZm9yY2UgPyB0YWJsZS5zZWxlY3Qobm90KFsnY29tbXVuaXR5Lm5vZGVDb3VudCcsICdjb21tdW5pdHkuY2hpbGRDb3VudCddKSkgOiB0YWJsZTsKICBjb25zdCBtZXJnZWRDaGlsZENvdW50ID0gY2hlY2tBbmRBZGRDaGlsZENvdW50KHNlbGVjdGVkKTsKICBjb25zdCBtZXJnZWROb2RlQ291bnQgPSBjaGVja0FuZEFkZE5vZGVDb3VudChtZXJnZWRDaGlsZENvdW50KTsKICByZXR1cm4gbWVyZ2VkTm9kZUNvdW50Owp9Ci8qKg0KICogQ2hlY2sgdG8gZW5zdXJlIGEgdGFibGUgY29udGFpbnMgYW4gZXhwZWN0ZWQgY29sdW1uLg0KICogSWYgbm90LCBjeWNsZSB0aHJvdWdoIHZhbGlkIGFsdGVybmF0ZXMgYW5kIHJlbmFtZSBhcw0KICogdGhlIGV4cGVjdGVkIGNvbHVtbi4gSWYgc3RpbGwgbm8gc3VjY2VzcywgdXNlIGEgZmFsbGJhY2sNCiAqIGZ1bmN0aW9uIHRvIGRlZmluZSB0aGUgY29sdW1uLg0KICogQHBhcmFtIHRhYmxlDQogKiBAcGFyYW0gbmFtZQ0KICogQHBhcmFtIHZhcmlhbnRzDQogKiBAcGFyYW0gZmFsbGJhY2sNCiAqLwoKZnVuY3Rpb24gZW5zdXJlQ29sdW1uKHRhYmxlLCBuYW1lLCB2YXJpYW50cywgZmFsbGJhY2spIHsKICBpZiAoaGFzQ29sdW1uKHRhYmxlLCBuYW1lKSkgewogICAgcmV0dXJuIHRhYmxlOwogIH0KCiAgbGV0IGZpeGVkOwogIHZhcmlhbnRzLnNvbWUodmFyaWFudCA9PiB7CiAgICBpZiAoaGFzQ29sdW1uKHRhYmxlLCB2YXJpYW50KSkgewogICAgICBmaXhlZCA9IHRhYmxlLnNlbGVjdChhbGwoKSwgewogICAgICAgIFt2YXJpYW50XTogbmFtZQogICAgICB9KTsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgcmV0dXJuIGZhbHNlOwogIH0pOwogIHJldHVybiBmaXhlZCB8fCBmYWxsYmFjayh0YWJsZSk7Cn0KLyoqDQogKiBDaGVjayB0aGUgY29sdW1ucyB0byBtYWtlIHN1cmUgd2UgaGF2ZSBhIG5vZGUuaWQsDQogKiBmYWxsaW5nIGJhY2sgb24gb3RoZXIgY29tbW9uIG9wdGlvbnMuDQogKiBJbiB0aGUgd29yc3QgY2FzZSwgd2Ugc2VsZWN0IHRoZSBmaXJzdCBjb2x1bW4uDQogKiBAcGFyYW0gdGFibGUNCiAqLwoKCmZ1bmN0aW9uIGVuc3VyZU5vZGVJZCh0YWJsZSkgewogIHJldHVybiBlbnN1cmVDb2x1bW4odGFibGUsICdub2RlLmlkJywgWydpZCcsICdJRCcsICdub2RlSWQnXSwgdGFibGUgPT4gewogICAgLy8ganVzdCBwaWNrIHRoZSBmaXJzdCAtIHRoaXMgaXMgcmlza3ksIGJ1dCBzb21ldGltZXMgd2UgZG9uJ3QgaGF2ZSBhIGhlYWRlciBhdCBhbGwKICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmNvbHVtbk5hbWVzKClbMF07CiAgICByZXR1cm4gdGFibGUuc2VsZWN0KGFsbCgpLCB7CiAgICAgIFtjb2x1bW5dOiAnbm9kZS5pZCcKICAgIH0pOwogIH0pOwp9Ci8qKg0KICogQ2hlY2sgdGhlIGNvbHVubnMgdG8gbWFrZSBzdXJlIHdlIGhhdmUgYSBjb21tdW5pdHkgaWQgKCdjaWQnKS4NCiAqIFRoaXMgaXMgcmVxdWlyZWQgYXQgYSBiYXNpYyBsZXZlbCBmb3IgYWxsIG5vZGUgdGFibGVzLCBzbyBpZiBvbmUgaXNuJ3QNCiAqIHByZXNlbnQgd2UganVzdCBkZWZhdWx0IHRvICcwJyBhcyBhbiBpZA0KICogQHBhcmFtIHRhYmxlDQogKi8KCgpmdW5jdGlvbiBlbnN1cmVDb21tdW5pdHlJZCh0YWJsZSkgewogIHJldHVybiBlbnN1cmVDb2x1bW4odGFibGUsICdjb21tdW5pdHkuaWQnLCBbJ25vZGUuY29tbXVuaXR5JywgJ2NpZCcsICdjb21tdW5pdHknLCAnY2x1c3RlcklkJ10sIHRhYmxlID0+IHsKICAgIHJldHVybiB0YWJsZS5kZXJpdmUoewogICAgICAnY29tbXVuaXR5LmlkJzogKCkgPT4gJzAnCiAgICB9KTsKICB9KTsKfQoKZnVuY3Rpb24gZW5zdXJlUGFyZW50Q29tbXVuaXR5SWQodGFibGUpIHsKICByZXR1cm4gZW5zdXJlQ29sdW1uKHRhYmxlLCAnY29tbXVuaXR5LnBpZCcsIFsncGlkJywgJ3BhcmVudENsdXN0ZXInLCAncGFyZW50J10sIHRhYmxlID0+IHsKICAgIHJldHVybiB0YWJsZS5wYXJhbXMoewogICAgICBwaWQ6IFJPT1RfQ09NTVVOSVRZX0lECiAgICB9KS5kZXJpdmUoewogICAgICAnY29tbXVuaXR5LnBpZCc6IChfLCAkKSA9PiAkLnBpZAogICAgfSk7CiAgfSk7Cn0gLy8gVEVNUDogbWFrZSBzdXJlIHRoZXJlIGFyZSBubyBlbXB0aWVzLCB3aGljaCBzb21lIGNzdnMgaGF2ZQovLyB1c2Ugb3VyIC0xIGRlZmF1bHQuCi8vIFRPRE86IHVzZSBlbXB0eSBhcyBkZWZhdWx0IGluc3RlYWQgb2YgLTEsIHdoaWNoIG5lZWQgYnJvYWRlciByZWZhY3RvcgoKCmZ1bmN0aW9uIGZpeFBpZCh0YWJsZSkgewogIHJldHVybiB0YWJsZS5wYXJhbXMoewogICAgcGlkOiBST09UX0NPTU1VTklUWV9JRAogIH0pLmRlcml2ZSh7CiAgICAnY29tbXVuaXR5LnBpZCc6IChkLCAkKSA9PiBkWydjb21tdW5pdHkucGlkJ10gfHwgJC5waWQKICB9KTsKfQoKZnVuY3Rpb24gZW5zdXJlWCh0YWJsZSkgewogIHJldHVybiBlbnN1cmVDb2x1bW4odGFibGUsICdub2RlLngnLCBbJ3gnLCAnWCddLCB0YWJsZSA9PiB7CiAgICByZXR1cm4gdGFibGUuZGVyaXZlKHsKICAgICAgJ25vZGUueCc6ICgpID0+IE1hdGgucmFuZG9tKCkKICAgIH0pOwogIH0pOwp9CgpmdW5jdGlvbiBlbnN1cmVZKHRhYmxlKSB7CiAgcmV0dXJuIGVuc3VyZUNvbHVtbih0YWJsZSwgJ25vZGUueScsIFsneScsICdZJ10sIHRhYmxlID0+IHsKICAgIHJldHVybiB0YWJsZS5kZXJpdmUoewogICAgICAnbm9kZS55JzogKCkgPT4gTWF0aC5yYW5kb20oKQogICAgfSk7CiAgfSk7Cn0KCmZ1bmN0aW9uIGVuc3VyZUQodGFibGUpIHsKICByZXR1cm4gZW5zdXJlQ29sdW1uKHRhYmxlLCAnbm9kZS5kJywgWydkJywgJ0QnLCAnc2l6ZScsICd3ZWlnaHQnXSwgdGFibGUgPT4gewogICAgcmV0dXJuIHRhYmxlLmRlcml2ZSh7CiAgICAgICdub2RlLmQnOiAoKSA9PiAxCiAgICB9KTsKICB9KTsKfQoKZnVuY3Rpb24gZW5zdXJlTm9kZUxhYmVsKHRhYmxlKSB7CiAgcmV0dXJuIGVuc3VyZUNvbHVtbih0YWJsZSwgJ25vZGUubGFiZWwnLCBbJ2xhYmVsJywgJ25hbWUnXSwgdGFibGUgPT4gewogICAgcmV0dXJuIHRhYmxlLmRlcml2ZSh7CiAgICAgICdub2RlLmxhYmVsJzogZCA9PiBkWydub2RlLmlkJ10KICAgIH0pOwogIH0pOwp9CgpmdW5jdGlvbiBlbnN1cmVFZGdlU291cmNlKHRhYmxlKSB7CiAgcmV0dXJuIGVuc3VyZUNvbHVtbih0YWJsZSwgJ2VkZ2Uuc291cmNlJywgWydzb3VyY2UnLCAnc3JjJ10sIHRhYmxlID0+IHsKICAgIHJldHVybiB0YWJsZS5kZXJpdmUoewogICAgICAnZWRnZS5zb3VyY2UnOiAoKSA9PiAnMCcKICAgIH0pOwogIH0pOwp9CgpmdW5jdGlvbiBlbnN1cmVFZGdlVGFyZ2V0KHRhYmxlKSB7CiAgcmV0dXJuIGVuc3VyZUNvbHVtbih0YWJsZSwgJ2VkZ2UudGFyZ2V0JywgWyd0YXJnZXQnLCAndGd0J10sIHRhYmxlID0+IHsKICAgIHJldHVybiB0YWJsZS5kZXJpdmUoewogICAgICAnZWRnZS50YXJnZXQnOiAoKSA9PiAnMScKICAgIH0pOwogIH0pOwp9CgpmdW5jdGlvbiBlbnN1cmVFZGdlV2VpZ2h0KHRhYmxlKSB7CiAgcmV0dXJuIGVuc3VyZUNvbHVtbih0YWJsZSwgJ2VkZ2Uud2VpZ2h0JywgWyd3ZWlnaHQnLCAndmFsdWUnXSwgdGFibGUgPT4gewogICAgcmV0dXJuIHRhYmxlLmRlcml2ZSh7CiAgICAgICdlZGdlLndlaWdodCc6ICgpID0+IDEKICAgIH0pOwogIH0pOwp9CgpmdW5jdGlvbiBlbnN1cmVFZGdlSWQodGFibGUpIHsKICByZXR1cm4gZW5zdXJlQ29sdW1uKHRhYmxlLCAnZWRnZS5pZCcsIFsnaWQnLCAnZWRnZUlkJ10sIHRhYmxlID0+IHsKICAgIHJldHVybiB0YWJsZS5kZXJpdmUoewogICAgICAnZWRnZS5pZCc6IGQgPT4gYCR7ZFsnZWRnZS5zb3VyY2UnXX0tJHtkWydlZGdlLnRhcmdldCddfWAKICAgIH0pOwogIH0pOwp9IC8vIG5vcm1hbGl6ZXMgeCBhbmQgeSBpbiBhIHNpbmdsZSBvcGVyYXRpb24gYmVjYXVzZSB3ZSBuZWVkIHRvIG1haW50YWluIGFzcGVjdCByYXRpbwoKCmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVYWSh0YWJsZSkgewogIGNvbnN0IGJvdW5kcyA9IHRhYmxlLnJvbGx1cCh7CiAgICB4TWluOiBvcC5taW4oJ25vZGUueCcpLAogICAgeE1heDogb3AubWF4KCdub2RlLngnKSwKICAgIHlNaW46IG9wLm1pbignbm9kZS55JyksCiAgICB5TWF4OiBvcC5tYXgoJ25vZGUueScpCiAgfSk7CiAgY29uc3QgeFJhbmdlID0gYm91bmRzLmdldCgneE1heCcsIDApICsgTWF0aC5hYnMoYm91bmRzLmdldCgneE1pbicsIDApKTsKICBjb25zdCB5UmFuZ2UgPSBib3VuZHMuZ2V0KCd5TWF4JywgMCkgKyBNYXRoLmFicyhib3VuZHMuZ2V0KCd5TWluJywgMCkpOwogIGNvbnN0IGFzcGVjdCA9IHhSYW5nZSAvIHlSYW5nZTsKICByZXR1cm4gdGFibGUucGFyYW1zKHsKICAgIHhNaW46IE1hdGguYWJzKGJvdW5kcy5nZXQoJ3hNaW4nLCAwKSksCiAgICB4UmFuZ2UsCiAgICB5TWluOiBNYXRoLmFicyhib3VuZHMuZ2V0KCd5TWluJywgMCkpLAogICAgeVJhbmdlLAogICAgYXNwZWN0CiAgfSkuZGVyaXZlKHsKICAgICdub2RlLngnOiAoZCwgJCkgPT4gKGRbJ25vZGUueCddICsgJC54TWluKSAvICQueFJhbmdlICogJC5hc3BlY3QsCiAgICAnbm9kZS55JzogKGQsICQpID0+IChkWydub2RlLnknXSArICQueU1pbikgLyAkLnlSYW5nZQogIH0pOwp9CgpmdW5jdGlvbiBub3JtYWxpemVEKHRhYmxlKSB7CiAgLy8gZm9yIHRoZSBub2RlIHNpemUsIHRoZSByYW5nZSBzaG91bGQgYWx3YXlzIGJlIHBvc2l0aXZlCiAgLy8gd2UgdXN1YWxseSBzcGVjaWZ5IGEgbWluaW11bSBvZiA1IGluIHRoZSBmaWxlcyAtIHdlIGRvCiAgLy8gbm90IHdhbnQgdGhvc2UgZ29pbmcgdG8gMCBvbmNlIG5vcm1hbGl6ZWQsIHNvIGhlcmUgd2UKICAvLyBqdXN0IG5vcm0gYnkgdGhlIG1heAogIGNvbnN0IGJvdW5kcyA9IHRhYmxlLnJvbGx1cCh7CiAgICBtYXg6IG9wLm1heCgnbm9kZS5kJykKICB9KTsKICByZXR1cm4gdGFibGUucGFyYW1zKHsKICAgIG1heDogYm91bmRzLmdldCgnbWF4JywgMCkKICB9KS5kZXJpdmUoewogICAgJ25vZGUuZCc6IChkLCAkKSA9PiBkWydub2RlLmQnXSAvICQubWF4CiAgfSk7Cn0KCmNvbnN0IHByZWZpeGVzID0gewogIG5vZGU6IHRydWUsCiAgY29tbXVuaXR5OiB0cnVlLAogIGVkZ2U6IHRydWUKfTsgLy8gb3VyIGN1cnJlbnQgImRhdGEgbW9kZWwiIGV4cGVjdHMgZXZlcnkgY29sdW1uIHRvIGhhdmUgYSB0eXBlIHByZWZpeAovLyB1c2VkIGZvciBmaWx0ZXJpbmcgdmlld3MsIGV0Yy4KLy8gdGhpcyB3aWxsIGZpbmQgYW55IHVucHJlZml4ZWQgY29sdW1ucyBhbmQgYWRkIHRoZSBzcGVjaWZpZWQgb25lIHRvIHRoZW0KCmZ1bmN0aW9uIHByZWZpeFJlbWFpbmluZyh0YWJsZSwgcHJlZml4KSB7CiAgY29uc3QgY29sdW1ucyA9IHRhYmxlLmNvbHVtbk5hbWVzKG5hbWUgPT4gewogICAgY29uc3QgcHJlZiA9IG5hbWUuc3BsaXQoJy4nKVswXTsKICAgIHJldHVybiAhcHJlZml4ZXNbcHJlZl07CiAgfSk7CiAgY29uc3Qgc3BlYyA9IGNvbHVtbnMucmVkdWNlKChhY2MsIGNvbCkgPT4gewogICAgYWNjW2NvbF0gPSBgJHtwcmVmaXh9LiR7Y29sfWA7CiAgICByZXR1cm4gYWNjOwogIH0sIHt9KTsKICByZXR1cm4gdGFibGUuc2VsZWN0KGFsbCgpLCBzcGVjKTsKfQovKioNCiAqIEFwcGx5IGEgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYSB0YWJsZSBpbiBzZXJpZXMsIHJldHVybmluZyB0aGUgZmluYWwgb3V0cHV0Lg0KICogSGVscGVyIGJlY2F1c2UgQXJxdWVybyBkb2VzIG5vdCBoYXZlIHNvbWV0aGluZyBha2luIHRvIGQzJ3MgYGNhbGxgLg0KICogQHBhcmFtIHRhYmxlDQogKiBAcGFyYW0gZnVuY3Rpb25zDQogKi8KCgpleHBvcnQgZnVuY3Rpb24gY2hhaW4odGFibGUsIGZ1bmN0aW9ucykgewogIHJldHVybiBmdW5jdGlvbnMucmVkdWNlKChhY2MsIGN1cikgPT4gY3VyKGFjYyksIHRhYmxlKTsKfQovKioNCiAqIFRha2UgYSBzdGFydGVyIG5vZGUgdGFibGUgYW5kIGVuc3VyZSBpdCBoYXMgYWxsIHRoZSByZXF1aXJlZCBjb2x1bW5zIChvciBkZWZhdWx0IHZhbHVlcykNCiAqIEBwYXJhbSB0YWJsZQ0KICogQHBhcmFtIHR5cGUNCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVOb2RlVGFibGUodGFibGUsIGZyb21FZGdlcyA9IGZhbHNlKSB7CiAgY29uc3Qgc3RhcnRlciA9IGZyb21FZGdlcyA/IHRhYmxlLmZvbGQoWydzb3VyY2UnLCAndGFyZ2V0J10pLmRlZHVwZSgndmFsdWUnKS51bmdyb3VwKCkuc2VsZWN0KHsKICAgIHZhbHVlOiAnaWQnCiAgfSkgOiB0YWJsZTsKICByZXR1cm4gY2hhaW4oc3RhcnRlciwgW2Vuc3VyZU5vZGVJZCwgZW5zdXJlTm9kZUxhYmVsLCBlbnN1cmVDb21tdW5pdHlJZCwgZW5zdXJlUGFyZW50Q29tbXVuaXR5SWQsIGVuc3VyZVgsIGVuc3VyZVksIGVuc3VyZUQsIG5vcm1hbGl6ZVhZLCBub3JtYWxpemVELCB0YWJsZSA9PiBwcmVmaXhSZW1haW5pbmcodGFibGUsICdub2RlJyksIGNoZWNrQW5kQWRkQ2hpbGRDb3VudCwgY2hlY2tBbmRBZGROb2RlQ291bnRdKTsKfQpleHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUpvaW5UYWJsZSh0YWJsZSkgewogIHJldHVybiBjaGFpbih0YWJsZSwgW2Vuc3VyZU5vZGVJZCwgZW5zdXJlQ29tbXVuaXR5SWRdKTsKfQpleHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUVkZ2VUYWJsZSh0YWJsZSkgewogIHJldHVybiBjaGFpbih0YWJsZSwgW2Vuc3VyZUVkZ2VTb3VyY2UsIGVuc3VyZUVkZ2VUYXJnZXQsIGVuc3VyZUVkZ2VJZCwgZW5zdXJlRWRnZVdlaWdodCwgdGFibGUgPT4gcHJlZml4UmVtYWluaW5nKHRhYmxlLCAnZWRnZScpXSk7Cn0KZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVDb21tdW5pdHlUYWJsZSh0YWJsZSkgewogIHJldHVybiBjaGFpbih0YWJsZSwgW2Vuc3VyZUNvbW11bml0eUlkLCB0YWJsZSA9PiBwcmVmaXhSZW1haW5pbmcodGFibGUsICdjb21tdW5pdHknKV0pOwp9CmV4cG9ydCBmdW5jdGlvbiBqb2luTm9kZUNvbW11bml0eVRhYmxlcyhub2RlcywgY29tbXVuaXRpZXMpIHsKICBjb25zdCBsZWZ0S2V5ID0gJ25vZGUuaWQnOwogIGNvbnN0IHJpZ2h0S2V5ID0gJ25vZGUuaWQnOyAvLyBlbnN1cmUgdGhlIGNvbW11bml0eSB0YWJsZSAocmlnaHQpCgogIGNvbnN0IHNhZmUgPSBjaGFpbihjb21tdW5pdGllcywgW2Vuc3VyZU5vZGVJZCwgZW5zdXJlQ29tbXVuaXR5SWQsIGVuc3VyZVBhcmVudENvbW11bml0eUlkLCBmaXhQaWQsIHRhYmxlID0+IHByZWZpeFJlbWFpbmluZyh0YWJsZSwgJ2NvbW11bml0eScpXSk7CiAgY29uc3Qgam9pbmVkID0gam9pbldpdGhSZXBsYWNlKG5vZGVzLCBzYWZlLCBbbGVmdEtleSwgcmlnaHRLZXldKTsgLy8gaWYgdGhlIGNvbW11bml0aWVzIGpvaW4gZG9lc24ndCBoYXZlIHByZWNvbXB1dGVzLCBydW4gdGhlbSBub3cKCiAgY29uc3Qgcm9sbHVwID0gcmVjb21wdXRlQ29tbXVuaXR5U3RhdHMoam9pbmVkLCAhaGFzQ29sdW1uKGNvbW11bml0aWVzLCAnY29tbXVuaXR5LmNoaWxkQ291bnQnKSB8fCAhaGFzQ29sdW1uKGNvbW11bml0aWVzLCAnY29tbXVuaXR5Lm5vZGVDb3VudCcpKTsKICByZXR1cm4gcm9sbHVwOwp9Ci8qKg0KICogU2ltcGxlIGpvaW4gdGhhdCByZXBsYWNlcyBhbnkgY29sdW1ucyBpbiB0aGUgbGVmdCB3aXRoIG1hdGNoaW5nIGNvbHVtbnMgaW4gdGhlIHJpZ2h0Lg0KICogTm9ybWFsIGFycXVlcm8gYmVoYXZpb3IgaXMgdGhlIHJlbmFtZSBjb2xsaXNpb25zLCBidXQgd2UgaGF2ZSBzbyBtdWNoIGRlcGVuZGVuY2Ugb24NCiAqIGV4cGVjdGVkIGNvbHVtbnMgdGhhdCB0aGlzIGNhdXNlcyBwcm9ibGVtcy4NCiAqIEl0J3MgZXNwZWNpYWxseSBmcmVxdWVudCBiZWNhdXNlIHRoZSBqb2luIGtleXMgYXJlIHJlbmFtZWQsDQogKiBzbyB0aGlzIGxldHMgdXMgam9pbiBhbmQgZXhjbHVkZSB0aGUga2V5DQogKiBAcGFyYW0gbGVmdA0KICogQHBhcmFtIHJpZ2h0DQogKiBAcGFyYW0gbGVmdEtleQ0KICogQHBhcmFtIHJpZ2h0S2V5DQogKi8KCmV4cG9ydCBmdW5jdGlvbiBqb2luV2l0aFJlcGxhY2UobGVmdCwgcmlnaHQsIGpvaW5EZWZpbml0aW9uKSB7CiAgcmV0dXJuIGxlZnQuam9pbihyaWdodCwgam9pbkRlZmluaXRpb24sIFtub3QocmlnaHQuY29sdW1uTmFtZXMoKSksIGFsbCgpXSk7Cn0KLyoqDQogKiBKb2luIGEgbmV3IHRhYmxlIHRvIGV4aXN0aW5nLCB1c2luZyBzdHJpY3QgcnVsZXMgb2YgaWQgYW5kIHByZWZpeC4NCiAqIEkuZS4sIHRoaXMgaXMgbm90IGEgZ2VuZXJhbC1wdXJwb3NlIGpvaW4gdXRpbCwgYnV0IHJhdGhlciBvbmUgdGhhdA0KICogc2ltcGxpZmllcyBvdXIgam9pbnMgYnkgYXNzdW1pbmcgYW4gaWQgY29sdW1uIGFuZCBhIHByZWZpeCBmb3Igb3V0cHV0IGNvbHVtbnMuDQogKiBAcGFyYW0gbGVmdA0KICogQHBhcmFtIHJpZ2h0DQogKiBAcGFyYW0gdHlwZQ0KICogQHBhcmFtIGxlZnRLZXkgb3B0aW9uYWwgZXhwbGljaXQgbGVmdCBrZXksIG90aGVyd2lzZSBpdCB3aWxsIHVzZSBgJHt0eXBlfS5pZGANCiAqIEBwYXJhbSByaWdodEtleSBvcHRpb25hbCBleHBsaWNpdCByaWdodCBrZXksIG90aGVyd2lzZSBpdCB3aWxsIHVzZSAnaWQnDQogKi8KCmV4cG9ydCBmdW5jdGlvbiBqb2luRGF0YVRhYmxlcyhsZWZ0LCByaWdodCwgdHlwZSwgbGVmdEtleSwgcmlnaHRLZXkgPSAnaWQnKSB7CiAgY29uc3Qgam9pbktleSA9IGxlZnRLZXkgfHwgYCR7dHlwZX0uaWRgOyAvLyBmb3IgYW55IG5ldyBjb2x1bW5zLCB3ZSdsbCBhZGQgdGhlIG9iamVjdCB0eXBlIHByZWZpeCAoaS5lLiwgbm9kZSBvciBjb21tdW5pdHkpLAogIC8vIGFuZCBwcmVzZXJ2ZSB0aGUgcmVxdWlyZWQgJ2lkJyBjb2x1bW4uIG5vdGUgdGhhdCBub2RlIGFuZCBjb21tdW5pdHkgaWRzIGFyZSBzdG9yZWQgYXMKICAvLyBzdHJpbmdzIGluIGNzdiwgc28gd2UgbmVlZCB0byBvdmVycmlkZSBwb3RlbnRpYWwgYXV0b3R5cGluZyBwZXJmb3JtZWQgYnkgYXJxdWVybwogIC8vIFRPRE86IHRoaXMgZGlzYWxsb3dzIGpvaW5pbmcgb2YgZXhpc3RpbmcgY29sdW1ucywKICAvLyBiZWNhdXNlIHRoYXQgcmVzdWx0cyBpbiB1bnByZWRpY3RhYmxlIGNvbHVtbiBuYW1lcwogIC8vIHdlIGNvdWxkIGFsbG93IG92ZXJ3cml0ZSBPUiBtYWtlIHN1cmUgdGhlIG5ldyBjb2x1bW5zIGhhdmUgYW4gaW50ZW50aW9uYWwgbmV3IHN1ZmZpeCBzbyB0aGUgZXhpc3Rpbmcgb25lcwogIC8vIGRvIG5vdCByZWNlaXZlIGEgbmV3IHN1ZmZpeAogIC8vIGF2b2lkIGV4aXN0aW5nIGNvbHVtbnMgc28gdGhleSBkb24ndCBjb2xsaWRlCiAgLy8gdW5sZXNzIHdlJ3JlIGRvaW5nIHRoYXQgb24gcHVycG9zZSEKCiAgY29uc3QgZXhjbHVkZSA9IG5ldyBTZXQobGVmdC5jb2x1bW5OYW1lcygpKTsKCiAgY29uc3QgZmlsdGVyID0gbmFtZSA9PiAhZXhjbHVkZS5oYXMobmFtZSk7IC8vIFRPRE86IGZsZXhpYmlsaXR5IGlkZWFzOiB3ZSByZXF1aXJlIGFuIElEIGNvbHVtbiBub3csIGJ1dCB0aGlzIGNvdWxkIGFsc28gKGEpIGp1c3QgdXNlIHRoZSBmaXJzdCBjb2x1bW4sCiAgLy8gYW5kIChiKSBhdXRvLWdlbmVyYXRlIGFuIGluY3JlbWVudGFsIGlkIGlmIG5vbmUgYXBwZWFycyBwcmVzZW50CgoKICBjb25zdCB0b01lcmdlID0gcmlnaHQgLy8gcmVuYW1lIGFsbCBuZXcgY29sdW1ucyB3aXRoIHRoZWlyIHByZWZpeCBleGNlcHQgdGhlIGlkCiAgLnNlbGVjdCh0YWJsZSA9PiByZW5hbWUodGFibGUsIGAke3R5cGV9LmAsIFtyaWdodEtleV0pKS5zZWxlY3QodGFibGUgPT4gdGFibGUuY29sdW1uTmFtZXMoZmlsdGVyKSk7CiAgcmV0dXJuIGxlZnQuam9pbih0b01lcmdlLCBbam9pbktleSwgcmlnaHRLZXldLCBbYWxsKCksIG5vdChyaWdodEtleSldKTsKfQovKioNCiAqIFRoaXMgY2hlY2tzIHRoZSBtYWluIHRhYmxlIGZvciBjb21tdW5pdHkuY2hpbGRDb3VudCBjb2x1bW4gYW5kIGNvbXB1dGVzIGlmIG1pc3NpbmcNCiAqIEBwYXJhbSBtYWluIGN1cnJlbnQgZnVsbHktcG9wdWxhdGVkIHRhYmxlIHdpdGggam9pbmVkIGNvbW11bml0aWVzDQogKiBAcGFyYW0gY29tbXVuaXRpZXMgZmxhdCBjb21tdW5pdHkgbGlzdCB0byByb2xsdXAgY2hpbGRDb3VudA0KICovCgpleHBvcnQgZnVuY3Rpb24gY2hlY2tBbmRBZGRDaGlsZENvdW50KG1haW4pIHsKICBpZiAoaGFzQ29sdW1uKG1haW4sICdjb21tdW5pdHkuY2hpbGRDb3VudCcpKSB7CiAgICByZXR1cm4gbWFpbjsKICB9IC8vIFRPRE86IGlzIHRoZXJlIGEgZmFzdGVyIHdheSB0byBjb21wdXRlIHRoaXMgd2l0aG91dCBpbnZvbHZpbmcgYSBzZWNvbmRhcnkgdGFibGU/CgoKICBjb25zdCBjaGlsZENvdW50ID0gbWFpbi5kZWR1cGUoJ2NvbW11bml0eS5pZCcpLmdyb3VwYnkoJ2NvbW11bml0eS5waWQnKS5jb3VudCh7CiAgICBhczogJ2NvbW11bml0eS5jaGlsZENvdW50JwogIH0pOwogIHJldHVybiBtYWluLmpvaW5fbGVmdChjaGlsZENvdW50LCBbJ2NvbW11bml0eS5pZCcsICdjb21tdW5pdHkucGlkJ10sIFthbGwoKSwgbm90KCdjb21tdW5pdHkucGlkJyldKS5kZXJpdmUoewogICAgLy8gam9pbiB3aWxsIGxlYXZlIGVtcHR5IGNlbGxzIHdoZXJlIHRoZXJlIGlzIG5vIG1hdGNoCiAgICAvLyBUT0RPOiBjYW4gam9pbiBvcCBiZSBlbmhhbmNlZCB0byBwcm92aWRlIGEgZmFsbGJhY2sgZmlsbD8KICAgICdjb21tdW5pdHkuY2hpbGRDb3VudCc6IGQgPT4gZFsnY29tbXVuaXR5LmNoaWxkQ291bnQnXSB8fCAwCiAgfSk7Cn0KLyoqDQogKiBUaGlzIGNoZWNrcyB0aGUgbWFpbiB0YWJsZSBmb3IgYSBjb21tdW5pdHkubm9kZUNvdW50IGNvbHVtbiBhbmQgY29tcHV0ZXMgaWYgbWlzc2luZw0KICogQHBhcmFtIG1haW4gY3VycmVudCBmdWxseS1wb3B1bGF0ZWQgdGFibGUgd2l0aCBqb2luZWQgY29tbXVuaXRpZXMNCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIGNoZWNrQW5kQWRkTm9kZUNvdW50KG1haW4pIHsKICBpZiAoaGFzQ29sdW1uKG1haW4sICdjb21tdW5pdHkubm9kZUNvdW50JykpIHsKICAgIHJldHVybiBtYWluOwogIH0KCiAgcmV0dXJuIG1haW4uZ3JvdXBieSgnY29tbXVuaXR5LmlkJykuZGVyaXZlKHsKICAgICdjb21tdW5pdHkubm9kZUNvdW50Jzogb3AuY291bnQoKQogIH0pLnVuZ3JvdXAoKTsKfQovKioNCiAqIENyZWF0ZSBhIHNldCBvZiBDb2x1bW5EZWZzIGJ5IGVudW1lcmF0aW5nIHRoZSB0YWJsZS4NCiAqIE9wdGlvbmFsIHNldCBvZiBjb2x1bW4gbmFtZXMgaW5kaWNhdGluZyB0aGV5IGFyZSByZWFkLW9ubHkgKGkuZS4sIG5vdCBkZWxldGFibGUgaW4gVUkpDQogKiBAcGFyYW0gdGFibGUNCiAqIEBwYXJhbSByZWFkT25seU5hbWVzDQogKi8KCmV4cG9ydCBmdW5jdGlvbiBsaXN0Q29sdW1uRGVmcyh0YWJsZSwgcmVhZE9ubHlOYW1lcykgewogIGlmICh0YWJsZS5udW1Sb3dzKCkgPT09IDApIHsKICAgIHJldHVybiBbXTsKICB9CgogIHJldHVybiB0YWJsZS5jb2x1bW5OYW1lcygpLm1hcChuYW1lID0+ICh7CiAgICBuYW1lLAogICAgdHlwZTogbmFtZS5zcGxpdCgnLicpWzBdLAogICAgZGF0YVR5cGU6IHR5cGVvZiB0YWJsZS5nZXQobmFtZSwgMCksCiAgICByZWFkT25seTogcmVhZE9ubHlOYW1lcyAmJiByZWFkT25seU5hbWVzLmhhcyhuYW1lKQogIH0pKTsKfQpleHBvcnQgZnVuY3Rpb24gbGlzdENvbHVtbk5hbWVzKHRhYmxlKSB7CiAgY29uc3QgZGVmcyA9IGxpc3RDb2x1bW5EZWZzKHRhYmxlKTsKICByZXR1cm4gZGVmcy5tYXAoZCA9PiBkLm5hbWUpOwp9CmV4cG9ydCBmdW5jdGlvbiBmaW5kR3JvdXBJbmRpY2VzKHRhYmxlLCBmaWVsZCwgdmFsdWUpIHsKICBpZiAodGFibGUubnVtUm93cygpID4gMCkgewogICAgY29uc3QgZ3JvdXBzID0gdGFibGUuZ3JvdXBzKCk7CiAgICBjb25zdCBpbmRleCA9IGdyb3Vwcy5yb3dzLmZpbmRJbmRleChyb3dJbmRleCA9PiB0YWJsZS5nZXQoZmllbGQsIHJvd0luZGV4KSA9PT0gdmFsdWUpOwogICAgcmV0dXJuIHRhYmxlLnBhcnRpdGlvbnMoKVtpbmRleF07CiAgfQp9"},{"version":3,"sources":["C:/ws/graph-drill/src/arquero/table.ts"],"names":["ROOT_COMMUNITY_ID","all","not","op","one","table","objects","rename","prefix","exclude","ex","Set","columnNames","reduce","obj","name","has","startsWith","hasColumn","column","some","columnTypes","numRows","map","type","get","recomputeCommunityStats","force","selected","select","mergedChildCount","checkAndAddChildCount","mergedNodeCount","checkAndAddNodeCount","ensureColumn","variants","fallback","fixed","variant","ensureNodeId","ensureCommunityId","derive","ensureParentCommunityId","params","pid","_","$","fixPid","d","ensureX","Math","random","ensureY","ensureD","ensureNodeLabel","ensureEdgeSource","ensureEdgeTarget","ensureEdgeWeight","ensureEdgeId","normalizeXY","bounds","rollup","xMin","min","xMax","max","yMin","yMax","xRange","abs","yRange","aspect","normalizeD","prefixes","node","community","edge","prefixRemaining","columns","pref","split","spec","acc","col","chain","functions","cur","initializeNodeTable","fromEdges","starter","fold","dedupe","ungroup","value","initializeJoinTable","initializeEdgeTable","initializeCommunityTable","joinNodeCommunityTables","nodes","communities","leftKey","rightKey","safe","joined","joinWithReplace","left","right","joinDefinition","join","joinDataTables","joinKey","filter","toMerge","main","childCount","groupby","count","as","join_left","listColumnDefs","readOnlyNames","dataType","readOnly","listColumnNames","defs","findGroupIndices","field","groups","index","rows","findIndex","rowIndex","partitions"],"mappings":"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","sourcesContent":["/*!\r\n * Copyright (c) Microsoft. All rights reserved.\r\n * Licensed under the MIT license. See LICENSE file in the project.\r\n */\r\nimport { ROOT_COMMUNITY_ID } from '../constants';\r\nimport { all, not, op } from 'arquero';\r\n/**\r\n * Extracts the objects from a single-row table.\r\n * This is commonly needed when doing rollups that output\r\n * a single row of stats.\r\n * @param table\r\n */\r\n// TODO: this is pretty basic, but the intent would be to provide optional\r\n// transformers per column or as a whole\r\nexport function one(table) {\r\n    return table.objects()[0];\r\n}\r\n/**\r\n * Return a selection mapping that renames columns with a prefix.\r\n * @param table table to enumerate and rename columns\r\n * @param prefix prefix to add to column names\r\n * @param exclude exclusion list if you want to retain some original columns\r\n */\r\nexport function rename(table, prefix, exclude) {\r\n    const ex = new Set(exclude);\r\n    return table.columnNames().reduce((obj, name) => {\r\n        if (ex.has(name) || name.startsWith(prefix)) {\r\n            obj[name] = name;\r\n        }\r\n        else {\r\n            obj[name] = `${prefix}${name}`;\r\n        }\r\n        return obj;\r\n    }, {});\r\n}\r\nexport function hasColumn(table, column) {\r\n    return table.columnNames().some(name => name === column);\r\n}\r\nexport function columnTypes(table) {\r\n    if (table.numRows() === 0) {\r\n        return [];\r\n    }\r\n    return table.columnNames().map(name => ({\r\n        name,\r\n        type: typeof table.get(name, 0),\r\n    }));\r\n}\r\nexport function recomputeCommunityStats(table, force) {\r\n    const selected = force\r\n        ? table.select(not(['community.nodeCount', 'community.childCount']))\r\n        : table;\r\n    const mergedChildCount = checkAndAddChildCount(selected);\r\n    const mergedNodeCount = checkAndAddNodeCount(mergedChildCount);\r\n    return mergedNodeCount;\r\n}\r\n/**\r\n * Check to ensure a table contains an expected column.\r\n * If not, cycle through valid alternates and rename as\r\n * the expected column. If still no success, use a fallback\r\n * function to define the column.\r\n * @param table\r\n * @param name\r\n * @param variants\r\n * @param fallback\r\n */\r\nfunction ensureColumn(table, name, variants, fallback) {\r\n    if (hasColumn(table, name)) {\r\n        return table;\r\n    }\r\n    let fixed;\r\n    variants.some(variant => {\r\n        if (hasColumn(table, variant)) {\r\n            fixed = table.select(all(), {\r\n                [variant]: name,\r\n            });\r\n            return true;\r\n        }\r\n        return false;\r\n    });\r\n    return fixed || fallback(table);\r\n}\r\n/**\r\n * Check the columns to make sure we have a node.id,\r\n * falling back on other common options.\r\n * In the worst case, we select the first column.\r\n * @param table\r\n */\r\nfunction ensureNodeId(table) {\r\n    return ensureColumn(table, 'node.id', ['id', 'ID', 'nodeId'], table => {\r\n        // just pick the first - this is risky, but sometimes we don't have a header at all\r\n        const column = table.columnNames()[0];\r\n        return table.select(all(), {\r\n            [column]: 'node.id',\r\n        });\r\n    });\r\n}\r\n/**\r\n * Check the colunns to make sure we have a community id ('cid').\r\n * This is required at a basic level for all node tables, so if one isn't\r\n * present we just default to '0' as an id\r\n * @param table\r\n */\r\nfunction ensureCommunityId(table) {\r\n    return ensureColumn(table, 'community.id', ['node.community', 'cid', 'community', 'clusterId'], table => {\r\n        return table.derive({\r\n            'community.id': () => '0',\r\n        });\r\n    });\r\n}\r\nfunction ensureParentCommunityId(table) {\r\n    return ensureColumn(table, 'community.pid', ['pid', 'parentCluster', 'parent'], table => {\r\n        return table\r\n            .params({\r\n            pid: ROOT_COMMUNITY_ID,\r\n        })\r\n            .derive({\r\n            'community.pid': (_, $) => $.pid,\r\n        });\r\n    });\r\n}\r\n// TEMP: make sure there are no empties, which some csvs have\r\n// use our -1 default.\r\n// TODO: use empty as default instead of -1, which need broader refactor\r\nfunction fixPid(table) {\r\n    return table\r\n        .params({\r\n        pid: ROOT_COMMUNITY_ID,\r\n    })\r\n        .derive({\r\n        'community.pid': (d, $) => d['community.pid'] || $.pid,\r\n    });\r\n}\r\nfunction ensureX(table) {\r\n    return ensureColumn(table, 'node.x', ['x', 'X'], table => {\r\n        return table.derive({\r\n            'node.x': () => Math.random(),\r\n        });\r\n    });\r\n}\r\nfunction ensureY(table) {\r\n    return ensureColumn(table, 'node.y', ['y', 'Y'], table => {\r\n        return table.derive({\r\n            'node.y': () => Math.random(),\r\n        });\r\n    });\r\n}\r\nfunction ensureD(table) {\r\n    return ensureColumn(table, 'node.d', ['d', 'D', 'size', 'weight'], table => {\r\n        return table.derive({\r\n            'node.d': () => 1,\r\n        });\r\n    });\r\n}\r\nfunction ensureNodeLabel(table) {\r\n    return ensureColumn(table, 'node.label', ['label', 'name'], table => {\r\n        return table.derive({\r\n            'node.label': (d) => d['node.id'],\r\n        });\r\n    });\r\n}\r\nfunction ensureEdgeSource(table) {\r\n    return ensureColumn(table, 'edge.source', ['source', 'src'], table => {\r\n        return table.derive({\r\n            'edge.source': () => '0',\r\n        });\r\n    });\r\n}\r\nfunction ensureEdgeTarget(table) {\r\n    return ensureColumn(table, 'edge.target', ['target', 'tgt'], table => {\r\n        return table.derive({\r\n            'edge.target': () => '1',\r\n        });\r\n    });\r\n}\r\nfunction ensureEdgeWeight(table) {\r\n    return ensureColumn(table, 'edge.weight', ['weight', 'value'], table => {\r\n        return table.derive({\r\n            'edge.weight': () => 1,\r\n        });\r\n    });\r\n}\r\nfunction ensureEdgeId(table) {\r\n    return ensureColumn(table, 'edge.id', ['id', 'edgeId'], table => {\r\n        return table.derive({\r\n            'edge.id': (d) => `${d['edge.source']}-${d['edge.target']}`,\r\n        });\r\n    });\r\n}\r\n// normalizes x and y in a single operation because we need to maintain aspect ratio\r\nexport function normalizeXY(table) {\r\n    const bounds = table.rollup({\r\n        xMin: op.min('node.x'),\r\n        xMax: op.max('node.x'),\r\n        yMin: op.min('node.y'),\r\n        yMax: op.max('node.y'),\r\n    });\r\n    const xRange = bounds.get('xMax', 0) + Math.abs(bounds.get('xMin', 0));\r\n    const yRange = bounds.get('yMax', 0) + Math.abs(bounds.get('yMin', 0));\r\n    const aspect = xRange / yRange;\r\n    return table\r\n        .params({\r\n        xMin: Math.abs(bounds.get('xMin', 0)),\r\n        xRange,\r\n        yMin: Math.abs(bounds.get('yMin', 0)),\r\n        yRange,\r\n        aspect,\r\n    })\r\n        .derive({\r\n        'node.x': (d, $) => ((d['node.x'] + $.xMin) / $.xRange) * $.aspect,\r\n        'node.y': (d, $) => (d['node.y'] + $.yMin) / $.yRange,\r\n    });\r\n}\r\nfunction normalizeD(table) {\r\n    // for the node size, the range should always be positive\r\n    // we usually specify a minimum of 5 in the files - we do\r\n    // not want those going to 0 once normalized, so here we\r\n    // just norm by the max\r\n    const bounds = table.rollup({\r\n        max: op.max('node.d'),\r\n    });\r\n    return table\r\n        .params({\r\n        max: bounds.get('max', 0),\r\n    })\r\n        .derive({\r\n        'node.d': (d, $) => d['node.d'] / $.max,\r\n    });\r\n}\r\nconst prefixes = {\r\n    node: true,\r\n    community: true,\r\n    edge: true,\r\n};\r\n// our current \"data model\" expects every column to have a type prefix\r\n// used for filtering views, etc.\r\n// this will find any unprefixed columns and add the specified one to them\r\nfunction prefixRemaining(table, prefix) {\r\n    const columns = table.columnNames(name => {\r\n        const pref = name.split('.')[0];\r\n        return !prefixes[pref];\r\n    });\r\n    const spec = columns.reduce((acc, col) => {\r\n        acc[col] = `${prefix}.${col}`;\r\n        return acc;\r\n    }, {});\r\n    return table.select(all(), spec);\r\n}\r\n/**\r\n * Apply a list of functions to a table in series, returning the final output.\r\n * Helper because Arquero does not have something akin to d3's `call`.\r\n * @param table\r\n * @param functions\r\n */\r\nexport function chain(table, functions) {\r\n    return functions.reduce((acc, cur) => cur(acc), table);\r\n}\r\n/**\r\n * Take a starter node table and ensure it has all the required columns (or default values)\r\n * @param table\r\n * @param type\r\n */\r\nexport function initializeNodeTable(table, fromEdges = false) {\r\n    const starter = fromEdges\r\n        ? table\r\n            .fold(['source', 'target'])\r\n            .dedupe('value')\r\n            .ungroup()\r\n            .select({ value: 'id' })\r\n        : table;\r\n    return chain(starter, [\r\n        ensureNodeId,\r\n        ensureNodeLabel,\r\n        ensureCommunityId,\r\n        ensureParentCommunityId,\r\n        ensureX,\r\n        ensureY,\r\n        ensureD,\r\n        normalizeXY,\r\n        normalizeD,\r\n        table => prefixRemaining(table, 'node'),\r\n        checkAndAddChildCount,\r\n        checkAndAddNodeCount,\r\n    ]);\r\n}\r\nexport function initializeJoinTable(table) {\r\n    return chain(table, [ensureNodeId, ensureCommunityId]);\r\n}\r\nexport function initializeEdgeTable(table) {\r\n    return chain(table, [\r\n        ensureEdgeSource,\r\n        ensureEdgeTarget,\r\n        ensureEdgeId,\r\n        ensureEdgeWeight,\r\n        table => prefixRemaining(table, 'edge'),\r\n    ]);\r\n}\r\nexport function initializeCommunityTable(table) {\r\n    return chain(table, [\r\n        ensureCommunityId,\r\n        table => prefixRemaining(table, 'community'),\r\n    ]);\r\n}\r\nexport function joinNodeCommunityTables(nodes, communities) {\r\n    const leftKey = 'node.id';\r\n    const rightKey = 'node.id';\r\n    // ensure the community table (right)\r\n    const safe = chain(communities, [\r\n        ensureNodeId,\r\n        ensureCommunityId,\r\n        ensureParentCommunityId,\r\n        fixPid,\r\n        table => prefixRemaining(table, 'community'),\r\n    ]);\r\n    const joined = joinWithReplace(nodes, safe, [leftKey, rightKey]);\r\n    // if the communities join doesn't have precomputes, run them now\r\n    const rollup = recomputeCommunityStats(joined, !hasColumn(communities, 'community.childCount') ||\r\n        !hasColumn(communities, 'community.nodeCount'));\r\n    return rollup;\r\n}\r\n/**\r\n * Simple join that replaces any columns in the left with matching columns in the right.\r\n * Normal arquero behavior is the rename collisions, but we have so much dependence on\r\n * expected columns that this causes problems.\r\n * It's especially frequent because the join keys are renamed,\r\n * so this lets us join and exclude the key\r\n * @param left\r\n * @param right\r\n * @param leftKey\r\n * @param rightKey\r\n */\r\nexport function joinWithReplace(left, right, joinDefinition) {\r\n    return left.join(right, joinDefinition, [not(right.columnNames()), all()]);\r\n}\r\n/**\r\n * Join a new table to existing, using strict rules of id and prefix.\r\n * I.e., this is not a general-purpose join util, but rather one that\r\n * simplifies our joins by assuming an id column and a prefix for output columns.\r\n * @param left\r\n * @param right\r\n * @param type\r\n * @param leftKey optional explicit left key, otherwise it will use `${type}.id`\r\n * @param rightKey optional explicit right key, otherwise it will use 'id'\r\n */\r\nexport function joinDataTables(left, right, type, leftKey, rightKey = 'id') {\r\n    const joinKey = leftKey || `${type}.id`;\r\n    // for any new columns, we'll add the object type prefix (i.e., node or community),\r\n    // and preserve the required 'id' column. note that node and community ids are stored as\r\n    // strings in csv, so we need to override potential autotyping performed by arquero\r\n    // TODO: this disallows joining of existing columns,\r\n    // because that results in unpredictable column names\r\n    // we could allow overwrite OR make sure the new columns have an intentional new suffix so the existing ones\r\n    // do not receive a new suffix\r\n    // avoid existing columns so they don't collide\r\n    // unless we're doing that on purpose!\r\n    const exclude = new Set(left.columnNames());\r\n    const filter = (name) => !exclude.has(name);\r\n    // TODO: flexibility ideas: we require an ID column now, but this could also (a) just use the first column,\r\n    // and (b) auto-generate an incremental id if none appears present\r\n    const toMerge = right\r\n        // rename all new columns with their prefix except the id\r\n        .select((table) => rename(table, `${type}.`, [rightKey]))\r\n        .select((table) => table.columnNames(filter));\r\n    return left.join(toMerge, [joinKey, rightKey], [all(), not(rightKey)]);\r\n}\r\n/**\r\n * This checks the main table for community.childCount column and computes if missing\r\n * @param main current fully-populated table with joined communities\r\n * @param communities flat community list to rollup childCount\r\n */\r\nexport function checkAndAddChildCount(main) {\r\n    if (hasColumn(main, 'community.childCount')) {\r\n        return main;\r\n    }\r\n    // TODO: is there a faster way to compute this without involving a secondary table?\r\n    const childCount = main\r\n        .dedupe('community.id')\r\n        .groupby('community.pid')\r\n        .count({ as: 'community.childCount' });\r\n    return main\r\n        .join_left(childCount, ['community.id', 'community.pid'], [all(), not('community.pid')])\r\n        .derive({\r\n        // join will leave empty cells where there is no match\r\n        // TODO: can join op be enhanced to provide a fallback fill?\r\n        'community.childCount': (d) => d['community.childCount'] || 0,\r\n    });\r\n}\r\n/**\r\n * This checks the main table for a community.nodeCount column and computes if missing\r\n * @param main current fully-populated table with joined communities\r\n */\r\nexport function checkAndAddNodeCount(main) {\r\n    if (hasColumn(main, 'community.nodeCount')) {\r\n        return main;\r\n    }\r\n    return main\r\n        .groupby('community.id')\r\n        .derive({\r\n        'community.nodeCount': op.count(),\r\n    })\r\n        .ungroup();\r\n}\r\n/**\r\n * Create a set of ColumnDefs by enumerating the table.\r\n * Optional set of column names indicating they are read-only (i.e., not deletable in UI)\r\n * @param table\r\n * @param readOnlyNames\r\n */\r\nexport function listColumnDefs(table, readOnlyNames) {\r\n    if (table.numRows() === 0) {\r\n        return [];\r\n    }\r\n    return table.columnNames().map(name => ({\r\n        name,\r\n        type: name.split('.')[0],\r\n        dataType: typeof table.get(name, 0),\r\n        readOnly: readOnlyNames && readOnlyNames.has(name),\r\n    }));\r\n}\r\nexport function listColumnNames(table) {\r\n    const defs = listColumnDefs(table);\r\n    return defs.map(d => d.name);\r\n}\r\nexport function findGroupIndices(table, field, value) {\r\n    if (table.numRows() > 0) {\r\n        const groups = table.groups();\r\n        const index = groups.rows.findIndex((rowIndex) => table.get(field, rowIndex) === value);\r\n        return table.partitions()[index];\r\n    }\r\n}\r\n"]}]}